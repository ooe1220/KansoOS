
# 目的
c言語の関数ポインタとは何かを理解します。
自作os上にて共通ライブラリを参照する際に関数ポインタを使用するため、本質的に理解する必要があります。

# 検証コード

```test.c
#include <stdio.h>

void hello() {
    printf("hello\n");
}

int main() {

    void (*fp)();

    fp = hello;

    printf("hello addr = %p\n", hello);
    printf("fp    addr = %p\n", fp);

    fp();   // 間接呼び出し
    
    asm volatile("int3");  // 実行を止める

    return 0;
}
```

# 検証

```bash
gcc -m32 -g test.c -o test
objdump -d test
readelf -l test

gdb ./test
run
info proc mappings
```

## ELF中hello関数のオフセット

ELFの内から`.text`セグメントの情報を確認します。
E(実行可能)がついたセグメントが`.text`セグメントです。

```
test@test-fujitsu:~/kaihatsu/ctest$ readelf -l test

Elf 文件类型为 DYN (Position-Independent Executable file)
Entry point 0x1080
There are 11 program headers, starting at offset 52

程序头：
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x00000034 0x00000034 0x00160 0x00160 R   0x4
  INTERP         0x000194 0x00000194 0x00000194 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x00000000 0x00000000 0x003f4 0x003f4 R   0x1000
  LOAD           0x001000 0x00001000 0x00001000 0x00260 0x00260 R E 0x1000　＜＜ここ
  LOAD           0x002000 0x00002000 0x00002000 0x00140 0x00140 R   0x1000
  LOAD           0x002ed4 0x00003ed4 0x00003ed4 0x00134 0x00138 RW  0x1000
  ...(省略)...
```

以下はELFの0x1000バイト目から読み出してメモリ仮想アドレス+0x1000に配置するという意味です。

```
  Type           Offset   VirtAddr 
  LOAD           0x001000 0x00001000
```

次に`hello`関数のオフセットを調べると`11ad`となっています。
```
test@test-fujitsu:~/kaihatsu/ctest$ objdump -d test

test：     文件格式 elf32-i386


Disassembly of section .init:

00001000 <_init>:
    1000:	f3 0f 1e fb          	endbr32 
    1004:	53                   	push   %ebx

...(省略)...

000011ad <hello>:
    11ad:	55                   	push   %ebp
    11ae:	89 e5                	mov    %esp,%ebp
    11b0:	53                   	push   %ebx

...(省略)...
```

## 実行時のメモリ読み込み位置を調べる

先ず前提としてメモリ上の読み込まれる位置は必ずしも固定とは限りません。
(筆者の自作OSは単純なので毎回同じ位置に読み込みます)
```
test@test-fujitsu:~/kaihatsu/ctest$ ./test
hello addr = 0x5956d1ad
fp    addr = 0x5956d1ad
hello
test@test-fujitsu:~/kaihatsu/ctest$ ./test
hello addr = 0x63dfa1ad
fp    addr = 0x63dfa1ad
hello
test@test-fujitsu:~/kaihatsu/ctest$ ./test
hello addr = 0x597b71ad
fp    addr = 0x597b71ad
hello
```

実行してからアドレスが確定されるため、GDB経由で実行して検証します。

```
test@test-fujitsu:~/kaihatsu/ctest$ gdb ./test

...(省略)...
hello addr = 0x565561ad
fp    addr = 0x565561ad
hello

Program received signal SIGTRAP, Trace/breakpoint trap.

main () at test.c:30
30	    return 0;
(gdb) info proc mappings
process 9321
Mapped address spaces:

	Start Addr   End Addr       Size     Offset  Perms   objfile
	0x56555000 0x56556000     0x1000        0x0  r--p   /home/test/kaihatsu/ctest/test
	0x56556000 0x56557000     0x1000     0x1000  r-xp   /home/test/kaihatsu/ctest/test　＜＜ここ
	0x56557000 0x56558000     0x1000     0x2000  r--p   /home/test/kaihatsu/ctest/test
	...(省略)...
```

r-xpのついているセグメントが`.text`です。
よって実行ファイルは`0x56556000`からの領域に読み込まれています。

# 関数ポインタとは
hello関数のELF中のオフセットは`11ad`です。
少しややこしいですが、hello関数の`.text`セグメント中でのオフセットは0x11ad-0x1000=0x1adとなり
0x56556000+0x1ad=0x565561adとなり実行結果のアドレスと一致します。

長くなりましたが要するに関数ポインタとは、CALL/JMP 命令の遷移先として使用できる実行アドレスでであるということです。



