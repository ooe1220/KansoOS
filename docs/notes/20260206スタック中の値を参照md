
# 目的
OS開発に当たりスタックを積み直すために、既にあるスタック中の値をESP基準で参照します。

# 検証コード

`int3`まで到達するとプログラムが止まるのでGDBからメモリ上の値を確認する。

```bash
gcc -m32 -g test.c -o test
gdb ./test
run
```

```test.c
#include <stdio.h>

int main() {

    asm volatile(
        "push $0x12345678\n"
        "push $0x99AABBCC\n"
        "push $0xDDEEFF12\n"
    );

    asm volatile("int3");   // GDBで止める

    return 0;
}
```

# スタック

```
(gdb) x/wx $esp
0xffffd1dc:	0xddeeff12
(gdb) x/wx $esp+4
0xffffd1e0:	0x99aabbcc
(gdb) x/wx $esp+8
0xffffd1e4:	0x12345678
```

以下の様になっている。直前にスタックへ積んだ値は`ESP`で表せる
push A
push B
push C

ESP → C
ESP+4 → B
ESP+8 → A

# ESPはアドレスの先頭を指すのか、お尻を指すのか

`0xddeeff12` は`ESP〜ESP+3`の4バイトに亙って保存されていますが、
ESPが指しているのは4バイトのうち一番低いアドレスを指している。
値だけ見るとお尻の`12`を指しているように見えます。

```bash
(gdb) x/bx $esp
0xffffd1dc:	0x12
(gdb) x/bx $esp+1
0xffffd1dd:	0xff
(gdb) x/bx $esp+2
0xffffd1de:	0xee
(gdb) x/bx $esp+3
0xffffd1df:	0xdd
```

図にするとこのようになっています。
```
低アドレス
┌────────┐ ← ESP
│   C    │
├────────┤ ← ESP+4
│   B    │
├────────┤ ← ESP+8
│   A    │
└────────┘
高アドレス
```

