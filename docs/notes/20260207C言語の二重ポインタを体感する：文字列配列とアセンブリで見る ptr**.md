
# ptr**は何を指すのか

```test.c
#include <stdio.h>

int main() {
    // 文字列ポインタの配列
    char *arr[] = {"Hello", "World", "C", "Lang", NULL};
    char **ptr = arr;

    // 一つずつ文字列を取り出して表示
    for (int i = 0; ptr[i] != NULL; i++) {
        printf("%p : ptr[%d] = \"%s\"\n", (void*)ptr[i], i, ptr[i]);

        // 文字毎に表示
        for (int j = 0; ptr[i][j] != '\0'; j++) {
            printf("%p :   ptr[%d][%d] = '%c'\n", 
                   (void*)&ptr[i][j], i, j, ptr[i][j]);
        }
        puts("");
    }

    return 0;
}
```

以下の書き方でも同義
```test.c
#include <stdio.h>

int main() {
    // 文字列ポインタの配列
    char *arr[] = {"Hello", "World", "C", "Lang", NULL};
    char **ptr = arr;  // 移動させるポインタ

    // 配列の終端までポインタを進めながら表示
    for (int i = 0; *ptr != NULL; ptr++, i++) {
        printf("%p : ptr[%d] = \"%s\"\n", (void*)*ptr, i, *ptr);

        // 文字列内の文字もポインタで進めて表示
        char *s = *ptr;
        for (int j = 0; *s != '\0'; s++, j++) {
            printf("%p :   ptr[%d][%d] = '%c'\n", 
                   (void*)s, i, j, *s);
        }
        puts("");
    }

    return 0;
}
```


```
test@test-fujitsu:~/kaihatsu/ctest$ gcc -m32 -O0 -g test.c -o test
test@test-fujitsu:~/kaihatsu/ctest$ ./test
0x5de7a008 : ptr[0] = "Hello"
0x5de7a008 :   ptr[0][0] = 'H'
0x5de7a009 :   ptr[0][1] = 'e'
0x5de7a00a :   ptr[0][2] = 'l'
0x5de7a00b :   ptr[0][3] = 'l'
0x5de7a00c :   ptr[0][4] = 'o'

0x5de7a00e : ptr[1] = "World"
0x5de7a00e :   ptr[1][0] = 'W'
0x5de7a00f :   ptr[1][1] = 'o'
0x5de7a010 :   ptr[1][2] = 'r'
0x5de7a011 :   ptr[1][3] = 'l'
0x5de7a012 :   ptr[1][4] = 'd'

0x5de7a014 : ptr[2] = "C"
0x5de7a014 :   ptr[2][0] = 'C'

0x5de7a016 : ptr[3] = "Lang"
0x5de7a016 :   ptr[3][0] = 'L'
0x5de7a017 :   ptr[3][1] = 'a'
0x5de7a018 :   ptr[3][2] = 'n'
0x5de7a019 :   ptr[3][3] = 'g'

test@test-fujitsu:~/kaihatsu/ctest$ 
```

ptr[0] と &ptr[0][0]は同じアドレスを指しますが、型は異なります。

ptr[0] : char*（ポインタ） 
意味　文字列の「先頭アドレス」

ptr[0][0] : char（値）
意味　文字列の「先頭文字」

# アセンブリ上での扱いを見てみる

```bash
gcc -m32 -ffreestanding -fno-pic -fno-pie -c test.c -o test.o
objdump -d -M intel test.o
objdump -s -j .rodata test.o
```

```test.c
#include <stdint.h>
#include <stddef.h>

int main() {
    // 文字列ポインタの配列
    volatile char *arr[] = {"Hello", "World", "C", "Lang", NULL};
    volatile char **ptr = arr;

    // ptr[0] を読む（char*）
    volatile char *p0 = ptr[0];

    // ptr[0][0] を読む（char）
    volatile char c0 = ptr[0][0];

    // ptr[0][1] を読む（char）
    volatile char c1 = ptr[0][1];

    return 0;
}
```

※注釈は筆者が自分で追加したものです。
```
test@test-fujitsu:~/kaihatsu/ctest$ objdump -d -M intel test.o

test.o：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <main>:
   0:	55                   	push   ebp
   1:	89 e5                	mov    ebp,esp
   3:	83 ec 20             	sub    esp,0x20
   
  ; char *arr[] = {"Hello", "World", "C", "Lang", NULL};
  ; それぞれの文字列開始オフセットをスタック上に展開する
  ; 32bit 環境なので ポインタ 1 個 = 4 バイト
   6:	c7 45 e4 00 00 00 00 	mov    DWORD PTR [ebp-0x1c],0x0 ; Hello" の開始オフセット
   d:	c7 45 e8 06 00 00 00 	mov    DWORD PTR [ebp-0x18],0x6 ; "World" の開始オフセット(未使用)
  14:	c7 45 ec 0c 00 00 00 	mov    DWORD PTR [ebp-0x14],0xc ; "C" の開始オフセット(未使用)
  1b:	c7 45 f0 0e 00 00 00 	mov    DWORD PTR [ebp-0x10],0xe ; "Lang" の開始オフセット(未使用)
  22:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0  ; NULL ポインタ(未使用)
  
  29:	8d 45 e4             	lea    eax,[ebp-0x1c]           ; eax に Hello" の開始オフセットを読み込む

  ; ptr[0] を p0 に保存
  2c:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax  ; ptr = arr;　文字列ポインタ配列の先頭
  2f:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]  ; [ebp-0x4]（ptr の値）を eax に読み込む
  32:	8b 00                	mov    eax,DWORD PTR [eax]      ; eax = ptr[0]
  34:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax  ; p0に保存
  
  ; ptr[0][0] を c0 に保存
  37:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
  3a:	8b 00                	mov    eax,DWORD PTR [eax]      ; eax = ptr[0] → "Hello"の先頭
  3c:	0f b6 00             	movzx  eax,BYTE PTR [eax]       ; eax = ptr[0][0] → 'H'　1バイト文字を eax に拡張
  3f:	88 45 e3             	mov    BYTE PTR [ebp-0x1d],al   ; c0 = 'H'
  
  ; ptr[0][1] を c1 に保存
  42:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
  45:	8b 00                	mov    eax,DWORD PTR [eax]
  47:	83 c0 01             	add    eax,0x1                  ; 文字列の次の文字に移動
  4a:	0f b6 00             	movzx  eax,BYTE PTR [eax]
  4d:	88 45 e2             	mov    BYTE PTR [ebp-0x1e],al
  
  50:	b8 00 00 00 00       	mov    eax,0x0 ; return 0;
  55:	c9                   	leave  
  56:	c3                   	ret    
test@test-fujitsu:~/kaihatsu/ctest$ objdump -s -j .rodata test.o

test.o：     文件格式 elf32-i386

Contents of section .rodata:
 0000 48656c6c 6f00576f 726c6400 43004c61  Hello.World.C.La
 0010 6e6700                               ng.             
test@test-fujitsu:~/kaihatsu/ctest$ 
```

絶対アドレスは確定していないので、アドレスの部分は全てオフセットになっている。

